{"ast":null,"code":"import { find, merge } from 'lodash';\nimport Events from './Events';\nimport Ids from './Ids';\nconst ids = new Ids();\nexport default class Granular {\n  constructor(options = {}) {\n    this.events = new Events();\n    const initialState = {\n      envelope: {\n        attack: random(0.1, 0.9),\n        release: random(0.1, 0.9)\n      },\n      density: random(0.1, 0.9),\n      spread: random(0.1, 0.9),\n      pitch: 1\n    };\n    this.state = {\n      isBufferSet: false,\n      envelope: {\n        attack: options.envelope && options.envelope.attack || initialState.envelope.attack,\n        release: options.envelope && options.envelope.release || initialState.envelope.release\n      },\n      density: options.density || initialState.density,\n      spread: options.spread || initialState.spread,\n      pitch: options.pitch || initialState.pitch,\n      voices: []\n    }; // audio\n\n    this.context = options.audioContext || new AudioContext();\n    this.gain = this.context.createGain();\n    this.gain.gain.value = 1; // connect to destination by default\n\n    this.gain.connect(this.context.destination);\n  }\n\n  connect(audioNode) {\n    this.gain.connect(audioNode);\n  }\n\n  disconnect() {\n    this.gain.disconnect();\n  }\n\n  on(events, listener) {\n    this.events.on(events, listener);\n  }\n\n  off(events, listener) {\n    this.events.off(events, listener);\n  }\n\n  set(state) {\n    this.state = merge(this.state, state);\n  }\n  /**\r\n   *\r\n   * @param {*} data\r\n   */\n\n\n  setBuffer(data) {\n    this.set({\n      isBufferSet: false\n    });\n    this.events.fire('settingBuffer', {\n      buffer: data\n    });\n\n    if (data instanceof AudioBuffer) {\n      // AudioBuffer\n      this.buffer = data;\n      this.set({\n        isBufferSet: true\n      });\n      this.events.fire('bufferSet', {\n        buffer: data\n      });\n      return;\n    }\n\n    return new Promise(resolve => {\n      // ArrayBuffer\n      this.context.decodeAudioData(data, buffer => {\n        this.buffer = buffer;\n        this.set({\n          isBufferSet: true\n        });\n        this.events.fire('bufferSet', {\n          buffer\n        });\n        resolve(buffer);\n      });\n    });\n  }\n\n  getVoice(id) {\n    return find(this.state.voices, voice => voice.id === id);\n  }\n  /**\r\n   *\r\n   * @param {Object} options - Options.\r\n   * @param {Object} [options.id] - Optional ID.\r\n   * @param {Object} [options.volume] - Optional volume (0.0 - 1.0).\r\n   * @param {Object} [options.position] - Optional position (0.0 - 1-0).\r\n   */\n\n\n  startVoice(options = {}) {\n    if (!this.state.isBufferSet) {\n      return;\n    } // keep reference\n\n\n    const self = this;\n\n    class Voice {\n      constructor(position, volume) {\n        this.position = position;\n        this.volume = volume;\n        this.grains = [];\n        this.grainsCount = 0;\n        this.timeout = null;\n      }\n\n      update(options = {}) {\n        if (options.position) {\n          this.position = options.position;\n        }\n\n        if (options.volume) {\n          this.volume = options.volume;\n        }\n      }\n\n      play() {\n        const _innerPlay = () => {\n          const grain = self.createGrain(this.position, this.volume);\n          this.grains[this.grainsCount] = grain;\n          this.grainsCount++;\n\n          if (this.grainsCount > 20) {\n            this.grainsCount = 0;\n          } // next interval\n\n\n          const density = map(self.state.density, 1, 0, 0, 1);\n          const interval = density * 500 + 70;\n          this.timeout = setTimeout(_innerPlay, interval);\n        };\n\n        _innerPlay();\n      }\n\n      stop() {\n        clearTimeout(this.timeout);\n      }\n\n    }\n\n    let position = options.position,\n        volume = options.volume,\n        id = options.id;\n\n    if (!position) {\n      position = 0;\n    }\n\n    if (!volume) {\n      volume = 1;\n    }\n\n    if (!id) {\n      id = ids.next();\n    }\n\n    const voice = new Voice(position, volume);\n    voice.play();\n    this.state.voices = [...this.state.voices, {\n      voice,\n      position,\n      volume,\n      id\n    }];\n    return id;\n  }\n\n  updateVoice(id, options) {\n    this.state.voices.forEach(voice => {\n      if (voice.id === id) {\n        voice.voice.update(options);\n      }\n    });\n  }\n\n  stopVoice(id) {\n    this.state.voices.forEach(voice => {\n      if (voice.id === id) {\n        voice.voice.stop();\n      }\n    });\n    const voices = this.state.voices.filter(v => v.id !== id);\n    this.set({\n      voices\n    });\n  }\n\n  createGrain(position, volume) {\n    const now = this.context.currentTime; // source\n\n    const source = this.context.createBufferSource();\n    source.playbackRate.value = source.playbackRate.value * this.state.pitch;\n    source.buffer = this.buffer; // gain\n\n    const gain = this.context.createGain();\n    source.connect(gain);\n    gain.connect(this.gain); // update position and calcuate offset\n\n    const offset = map(position, 0, 1, 0, this.buffer.duration); // volume\n\n    volume = clamp(volume, 0, 1); // parameters\n\n    const attack = this.state.envelope.attack * 0.4;\n    let release = this.state.envelope.release * 1.5;\n\n    if (release < 0) {\n      release = 0.1;\n    }\n\n    const randomoffset = Math.random() * this.state.spread - this.state.spread / 2; // envelope\n\n    source.start(now, Math.max(0, offset + randomoffset), attack + release);\n    gain.gain.setValueAtTime(0.0, now);\n    gain.gain.linearRampToValueAtTime(volume, now + attack);\n    gain.gain.linearRampToValueAtTime(0, now + (attack + release)); // garbage collection\n\n    source.stop(now + attack + release + 0.1);\n    const disconnectTime = (attack + release) * 1000;\n    setTimeout(() => {\n      gain.disconnect();\n    }, disconnectTime + 200);\n    this.events.fire('grainCreated', {\n      position,\n      volume,\n      pitch: this.state.pitch\n    });\n  }\n\n}\n\nfunction map(value, inMin, inMax, outMin, outMax) {\n  return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nfunction clamp(value, min, max) {\n  return Math.min(max, Math.max(min, value));\n}\n\nfunction random(min, max) {\n  return Math.floor(Math.random() * (max - min) * 10) / 10 + min;\n}","map":null,"metadata":{},"sourceType":"module"}